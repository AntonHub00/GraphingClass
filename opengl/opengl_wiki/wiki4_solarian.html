<!DOCTYPE html> <html dir="ltr" lang="en-US"> <head> <meta charset="utf-8"> <meta http-equiv="x-ua-compatible" content="ie=edge"> <title>OpenGL 101: Drawing primitives - points, lines and triangles | Solarian Programmer</title> <meta name="description" content="Introduction to OpenGL primitives points, lines and triangles"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/css/style.min.css"> <!--[if lt IE 9]><script type="text/javascript" src="/js/html5shiv.min.js"></script> <script type="text/javascript" src="/js/respond.min.js"></script> <script type="text/javascript" src="/js/jquery-1.11.2.min.js"></script> <script type="text/javascript" src="/js/bootstrap.min.js"></script><![endif]--> <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-25961119-1', 'solarianprogrammer.com');
            ga('set', 'anonymizeIp', true);
            ga('send', 'pageview');        
        </script> </head> <body> <!--[if lt IE 8]><p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p><![endif]--> <div class="container"> <header class="row"> <section id="title_subtitle" class="col-md-8 col-xs-6"> <h1 id="blog_title"> <a id="blog_title_link" href="https://solarianprogrammer.com" title="Solarian Programmer" rel="home">Solarian Programmer</a> </h1> <h4 id="blog_subtitle">My programming ramblings</h4> </section> <nav class="row links_pages_header"> <a class="col-md-1 links_pages_a" href="/">Home</a> <a class="col-md-1 links_pages_a" href="/archives/">Archives</a> <a class="col-md-1 links_pages_a" href="/contact/">Contact</a> <a class="col-md-1 links_pages_a" href="/privacy/">Privacy</a> </nav> </header> <section class="row"> <article class="col-md-8"> <section id="advert" class="col-md-4 col-xs-6"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5384871893435364" data-ad-slot="8698481522" data-ad-format="auto"></ins> <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script> </section> <h1 class="class_article_title"> OpenGL 101: Drawing primitives - points, lines and triangles </h1> <h2 class="class_article_title_date"> Posted on May 13, 2013 by Sol </h2> <p><em>The code for this post is on GitHub:</em> <a href="https://github.com/sol-prog/OpenGL-101" target="_blank">https://github.com/sol-prog/OpenGL-101</a>.</p> <p>This is the second article from my <em>OpenGL 101</em> series. In the <a href="/2013/05/10/opengl-101-windows-osx-linux-getting-started">first article</a> we’ve seen how to open a window for our OpenGL application with the <a href="http://www.glfw.org/">GLFW</a> library and how to compile and run the code on <em>Windows</em>, <em>OS X</em> and <em>Linux</em>. It is time to actually draw something using OpenGL.</p> <p>First, let me mention that OpenGL is a low level API, this means that it has no support for drawing complex geometrical objects. It is the programmer’s job to combine the geometrical primitives from OpenGL in complex shapes and bodies. The basic geometrical primitives that the core OpenGL profile provide to us are points, lines and triangles.</p> <p>For simplicity, we are going to use only two dimensional drawings in this article, but keep in mind that OpenGL allows us to represent three dimensional objects, more on this in a future article. For now, let’s try to draw the four triangles from the next figure:</p> <p><img src="/images/2013/05/13/reference_drawing.jpg" alt="Four triangles Cartesian system" width="500" class="center_image img-responsive"/></p> <p>From a geometrical point of view, a triangle is completely defined by the position in space of his three corners or vertices. In OpenGL terminology, a vertex can be seen as a collection of attributes like position, color, texture coordinates etc …</p> <p>In the above figure we have four triangles and twelve vertices. Each vertex from our figure has a position attribute, let’s ignore for the moment any other possible attribute like a color. We can store these vertices in a C++ array:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span>	<span class="n">GLfloat</span> <span class="n">vertices_position</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno"> 2 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno"> 3 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno"> 4 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 5 </span>
<span class="lineno"> 6 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno"> 7 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 8 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 9 </span>
<span class="lineno">10 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno">11 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno">12 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno">13 </span>
<span class="lineno">14 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="lineno">15 </span>		<span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno">16 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno">17 </span>	<span class="p">};</span>
</pre></div> <p>If you look closely, you may notice that the points are written counterclockwise, this is important to keep in mind. By default, in OpenGL, a triangle with his vertices stored in counterclockwise order is said to be <em>front facing</em>. Why is this distinction important? We can instruct OpenGL to render only one of the two faces of a triangle surface (the front or the back); the default is to render both faces. Another observation about the above array is that it stores only the <em>x</em>, <em>y</em> coordinates for our triangles, this is because the <em>z</em> coordinate is zero for all twelve vertices.</p> <p>So, how does OpenGL draws our triangles, now that we have their vertices in an array ? The first step is to transfer the content of the above array in a <em>Vertex Buffer Object</em>. A <em>Vertex Buffer Object</em>, or <em>VBO</em>, is a chunk of memory managed by OpenGL, basically it is a piece of the memory of your video card.</p> <p>A <em>VBO</em> needs to be created, allocated and filled with data. We can also fill the <em>VBO</em> with data in the allocation step:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="c1">// Create a Vector Buffer Object that will store the vertices on video memory</span>
<span class="lineno">2 </span>	<span class="n">GLuint</span> <span class="n">vbo</span><span class="p">;</span>
<span class="lineno">3 </span>	<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
<span class="lineno">4 </span>
<span class="lineno">5 </span>	<span class="c1">// Allocate space and upload the data from CPU to GPU</span>
<span class="lineno">6 </span>	<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
<span class="lineno">7 </span>	<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">),</span> <span class="n">vertices_position</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></div> <p>Line 3 from the above piece of code will create a handle for our <em>VBO</em>, using the <a href="http://www.opengl.org/sdk/docs/man/xhtml/glGenBuffers.xml"><em>glGenBuffers</em></a> function. Keep in mind that this function can create an array of handles if needed; for our particular case we have a single <em>VBO</em> so one handle will suffice. Once a <em>VBO</em> is created, we need to <em>bind</em> it in order to modify or use it, this is what line 6 does with the <a href="http://www.opengl.org/sdk/docs/man/xhtml/glBindBuffer.xml"><em>glBindBuffer</em></a> function. The last line will allocate space for the <em>VBO</em> and fill it with the content of our <em>vertices_position</em> array.</p> <p>Once we have our data in a <em>VBO</em>, we can send it through the OpenGL pipeline - a number of steps and transformations through which our vertices will pass; the result is written in a framebuffer. The <em>glfwSwapBuffers()</em> function from <em>GLFW</em> will replace the current, visible framebuffer (the surface of our window), with the result of the rendering process. A simplified scheme of the OpenGL pipeline is presented in the next figure:</p> <p><img src="/images/2013/05/13/simplified_pipeline.png" alt="OpenGL pipeline simplified" width="640" class="center_image img-responsive"/></p> <p>The above figure is a simplified model of the entire OpenGL pipeline, it doesn’t include any of the optional steps. From the point of view of a beginner, what is important in the above scheme are the <em>vertex shader</em> and the <em>fragment shader</em>. A shader is a, typically small, program that is executed on the video card. A shader is written in <em>GLSL</em>, the <em>OpenGL Shading Language</em>, a language similar with C.</p> <p>A vertex shader is executed for every vertex in a <em>VBO</em>, his role is to, potentially, apply various transformations on the vertices position attribute and pass through other attributes like color, texture coordinates etc … It is the programmer’s responsibility to write a vertex shader for every OpenGL based application.</p> <p>The next step, in our simplified model of the OpenGL pipeline, is the <em>Primitive Setup</em> stage that will organize the vertices into geometric primitives (points, lines and triangles) for the next two stages.</p> <p>In the clipping stage, the primitives that lies outside of the viewing volume are split in smaller primitives. The default viewing volume in OpenGL is a cube, [-1, +1] x [-1, +1] x [-1, +1], with the origin in the middle of the current viewport (a rectangular area of our window, for our case the viewport has the same dimensions as our window), the positive <em>x</em> axis points to the right, the positive <em>y</em> axis points up and the positive <em>z</em> axis points toward the viewer. If, for example, one of our triangles corners will be outside of the viewing volume, say at -2.0, 0, the clipping stage will split this triangle in smaller triangles and remove the triangles that are outside of the viewing volume. This stage is executed by OpenGL.</p> <p>In the rasterization stage, the primitives that exit the clipping stage are transformed into fragments. Which of these fragments will end as a pixel value in the final framebuffer is decided in the next stage of the pipeline. In the <a href="/2013/05/13/opengl-101-drawing-primitives#book">book</a> recommended at the end of this article, it is suggested to think at these fragments as <em>potential pixels</em>.</p> <p>The fragment shader, also the programmer’s responsibility, can potentially determine the fragment final color, discard some fragments, or use texture mapping.</p> <p>After the fragment shader, the color of a fragment can potentially be further modified if the depth and stencil tests are enabled, or if blending was enabled.</p> <p>From our simplified approach point of view, we are interested in the two mandatory shaders of any OpenGL core application, the vertex and the fragment shaders. In other words, we need to implement these two shaders if we want to draw something.</p> <p>Let’s start with the implementation of a simple vertex shader:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="cp">#version 150</span>
<span class="lineno">2 </span>
<span class="lineno">3 </span><span class="n">in</span> <span class="n">vec4</span> <span class="n">position</span><span class="p">;</span>
<span class="lineno">4 </span>
<span class="lineno">5 </span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">6 </span>	<span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
<span class="lineno">7 </span><span class="p">}</span>
</pre></div> <p>The first line of the above shader specifies the shader language used, for OpenGL 3.2 the corresponding shader language version is 1.50. Next, we have a global variable of type <em>vec4</em> that will receive the position of a vertex, a <em>GLSL</em> vector that can store 4 values, by default this is initialized with (0,0,0,1). A small note here, OpenGL represents internally any vertex position as a four value vector, we are going to talk more about this in a future article about Math in OpenGL :). From our point of view, if we send a two value x, y position to the shader, the last two numbers will remain with the default values of 0 and 1. Any shader needs a main function, like the one declared in line 5. Line 6 sets the value of an internal variable from <em>GLSL</em>, <em>gl_position</em>, to the value of our vertex position.</p> <p>Next, we present a simple fragment shader:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="cp">#version 150</span>
<span class="lineno">2 </span>
<span class="lineno">3 </span><span class="hll"><span class="n">out</span> <span class="n">vec4</span> <span class="n">out_color</span><span class="p">;</span>
</span><span class="lineno">4 </span>
<span class="lineno">5 </span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">6 </span><span class="hll">	<span class="n">out_color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span><span class="lineno">7 </span><span class="p">}</span>
</pre></div> <p>Line 3 of the fragment shader defines a global variable that will be used to set the color of every fragment to white, see line 6. As mentioned in the first article of this series, OpenGL uses internally a four dimensional color space, <em>RGBA</em>, in this space 1.0, 1.0, 1.0, 1.0 represents white opaque (no transparency).</p> <p>For maximum flexibility, we are going to save the above two shaders in two separate files <em>vert.shader</em> and <em>frag.shader</em>. Some authors keep the shaders in C-style strings in their code, while this avoids the need to read the shader files from the disk it will also require the recompilation of the entire application for any small change in the shaders. The real problem with the shader code stored as string in the C++ code is that when you have an error in your shader code it could be a bit difficult to find the corresponding error line. Another disadvantage is that you don’t have syntax highlighting in what your editor interprets as a constant string.</p> <p>First, we are going to need a function to read the shader from the disk, nothing spectacular here, just open a file and read the content, also check if the file is open, you can see the complete function on the Github repository:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="kt">void</span> <span class="nf">read_shader_src</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</pre></div> <p>Next, we are going to <em>compile</em> the shader, check the result of the compilation and print any error message:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span><span class="c1">// Compile a shader</span>
<span class="lineno"> 2 </span><span class="n">GLuint</span> <span class="nf">load_and_compile_shader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">shaderType</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 3 </span>	<span class="c1">// Load a shader from an external file</span>
<span class="lineno"> 4 </span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="lineno"> 5 </span>	<span class="n">read_shader_src</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="lineno"> 6 </span>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="lineno"> 7 </span>
<span class="lineno"> 8 </span>	<span class="c1">// Compile the shader</span>
<span class="lineno"> 9 </span>	<span class="n">GLuint</span> <span class="n">shader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">shaderType</span><span class="p">);</span>
<span class="lineno">10 </span>	<span class="n">glShaderSource</span><span class="p">(</span><span class="n">shader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="lineno">11 </span>	<span class="n">glCompileShader</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
<span class="lineno">12 </span>	<span class="c1">// Check the result of the compilation</span>
<span class="lineno">13 </span>	<span class="n">GLint</span> <span class="n">test</span><span class="p">;</span>
<span class="lineno">14 </span>	<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">shader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="p">);</span>
<span class="lineno">15 </span>	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">16 </span>		<span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Shader compilation failed with this message:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="lineno">17 </span>		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">compilation_log</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
<span class="lineno">18 </span>		<span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">shader</span><span class="p">,</span> <span class="n">compilation_log</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compilation_log</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="lineno">19 </span>		<span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">compilation_log</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="lineno">20 </span>		<span class="n">glfwTerminate</span><span class="p">();</span>
<span class="lineno">21 </span>		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="lineno">22 </span>	<span class="p">}</span>
<span class="lineno">23 </span>	<span class="k">return</span> <span class="n">shader</span><span class="p">;</span>
<span class="lineno">24 </span><span class="p">}</span>
</pre></div> <p>The last step in being able to use the shaders is to create a program from them:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span><span class="c1">// Create a program from two shaders</span>
<span class="lineno"> 2 </span><span class="n">GLuint</span> <span class="nf">create_program</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path_vert_shader</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path_frag_shader</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 3 </span>	<span class="c1">// Load and compile the vertex and fragment shaders</span>
<span class="lineno"> 4 </span>	<span class="n">GLuint</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">load_and_compile_shader</span><span class="p">(</span><span class="n">path_vert_shader</span><span class="p">,</span> <span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
<span class="lineno"> 5 </span>	<span class="n">GLuint</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">load_and_compile_shader</span><span class="p">(</span><span class="n">path_frag_shader</span><span class="p">,</span> <span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span>
<span class="lineno"> 6 </span>
<span class="lineno"> 7 </span>	<span class="c1">// Attach the above shader to a program</span>
<span class="lineno"> 8 </span>	<span class="n">GLuint</span> <span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span>
<span class="lineno"> 9 </span>	<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
<span class="lineno">10 </span>	<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
<span class="lineno">11 </span>
<span class="lineno">12 </span>	<span class="c1">// Flag the shaders for deletion</span>
<span class="lineno">13 </span>	<span class="n">glDeleteShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
<span class="lineno">14 </span>	<span class="n">glDeleteShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>
<span class="lineno">15 </span>
<span class="lineno">16 </span>	<span class="c1">// Link and use the program</span>
<span class="lineno">17 </span>	<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="lineno">18 </span>	<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="lineno">19 </span>
<span class="lineno">20 </span>	<span class="k">return</span> <span class="n">shaderProgram</span><span class="p">;</span>
<span class="lineno">21 </span><span class="p">}</span>
</pre></div> <p>What remains to be done in order to successfully use the above shader program is to make the connection between the code that runs on CPU and the one that runs on GPU (the shader program). Basically, we need to connect the input name from the vertex shader to the position attribute of our <em>VBO</em>. We also need to bind the output name from the fragment shader.</p> <p>OpenGL stores the information about the links between the attributes and the <em>VBO</em> in a special variable named <em>Vertex Array Object</em>, or <em>VAO</em>. Once a <em>VAO</em> is created and binded, all the information about where the data is located is stored in the <em>VAO</em>. This means that we need to bind a <em>VAO</em> before we transfer the data to a <em>VBO</em> or create the shader program and the links between inputs/outputs from the shader program.</p> <p>Time to put the pieces together. We are going to start with the last code from our last article, <em>ex_3.cpp</em>, let’s save this as <em>ex_4.cpp</em> and start adding the pieces presented above, you can find the complete code on the Github repository for this article as <em>ex_4.cpp</em>.</p> <p>First, we are going to add the functions used for managing shaders: <em>read_shader_src</em>, <em>load_and_compile_shader</em> and <em>create_program</em>. In the future, I will probably refactor the above three functions in a separate C++ class.</p> <p>We’ll also do some changes in the main function of our code:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span>	<span class="p">...</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span>	<span class="c1">// Initialize GLEW</span>
<span class="lineno"> 4 </span>	<span class="p">...</span>
<span class="lineno"> 5 </span>
<span class="lineno"> 6 </span>	<span class="c1">// Create a vertex array object</span>
<span class="lineno"> 7 </span><span class="hll">	<span class="n">GLuint</span> <span class="n">vao</span><span class="p">;</span>
</span><span class="lineno"> 8 </span>
<span class="lineno"> 9 </span>	<span class="c1">// Initialize the data to be rendered</span>
<span class="lineno">10 </span><span class="hll">	<span class="n">initialize</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
</span><span class="lineno">11 </span>
<span class="lineno">12 </span>	<span class="c1">// Create a rendering loop</span>
<span class="lineno">13 </span>	<span class="kt">int</span> <span class="n">running</span> <span class="o">=</span> <span class="n">GL_TRUE</span><span class="p">;</span>
<span class="lineno">14 </span>
<span class="lineno">15 </span>	<span class="k">while</span><span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">16 </span>		<span class="c1">// Display scene</span>
<span class="lineno">17 </span><span class="hll">		<span class="n">display</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
</span><span class="lineno">18 </span>
<span class="lineno">19 </span>		<span class="c1">// Pool for events</span>
<span class="lineno">20 </span>		<span class="n">glfwPollEvents</span><span class="p">();</span>
<span class="lineno">21 </span>		<span class="c1">// Check if the window was closed</span>
<span class="lineno">22 </span>		<span class="n">running</span> <span class="o">=</span> <span class="n">glfwGetWindowParam</span><span class="p">(</span><span class="n">GLFW_OPENED</span><span class="p">);</span>
<span class="lineno">23 </span>	<span class="p">}</span>
<span class="lineno">24 </span>
<span class="lineno">25 </span>	<span class="c1">// Terminate GLFW</span>
<span class="lineno">26 </span>	<span class="n">glfwTerminate</span><span class="p">();</span>
<span class="lineno">27 </span>
<span class="lineno">28 </span>	<span class="p">...</span>
</pre></div> <p>Line 7 from the above code creates a <em>VAO</em>, we are going to need this later, see the other two highlighted lines for changes.</p> <p>Line 10 calls a new function, <em>initialize</em>, which is used to store all the constant data from our code. Since we want to draw a static image, we could add most of the code in this new function. I’ve also moved the two lines of code used for filling the background with red, in a separate function, <em>display</em>.</p> <p>Let’s dissect the <em>initialize</em> function a bit:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span><span class="kt">void</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">GLuint</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 2 </span>	<span class="c1">// Use a Vertex Array Object</span>
<span class="lineno"> 3 </span><span class="hll">	<span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">);</span>
</span><span class="lineno"> 4 </span><span class="hll">	<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
</span><span class="lineno"> 5 </span>
<span class="lineno"> 6 </span>	<span class="c1">// 4 triangles to be rendered</span>
<span class="lineno"> 7 </span>	<span class="n">GLfloat</span> <span class="n">vertices_position</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno"> 8 </span>
<span class="lineno"> 9 </span>		<span class="p">...</span>
<span class="lineno">10 </span>
<span class="lineno">11 </span>	<span class="p">};</span>
<span class="lineno">12 </span>
<span class="lineno">13 </span>	<span class="c1">// Create a Vector Buffer Object that will store the vertices on video memory</span>
<span class="lineno">14 </span>	<span class="n">GLuint</span> <span class="n">vbo</span><span class="p">;</span>
<span class="lineno">15 </span>	<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
<span class="lineno">16 </span>
<span class="lineno">17 </span>	<span class="c1">// Allocate space and upload the data from CPU to GPU</span>
<span class="lineno">18 </span>	<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
<span class="lineno">19 </span>	<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">),</span> <span class="n">vertices_position</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="lineno">20 </span>
<span class="lineno">21 </span><span class="hll">	<span class="n">GLuint</span> <span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">create_program</span><span class="p">(</span><span class="s">&quot;shaders/vert.shader&quot;</span><span class="p">,</span> <span class="s">&quot;shaders/frag.shader&quot;</span><span class="p">);</span>
</span><span class="lineno">22 </span>
<span class="lineno">23 </span>	<span class="c1">// Get the location of the attributes that enters in the vertex shader</span>
<span class="lineno">24 </span><span class="hll">	<span class="n">GLint</span> <span class="n">position_attribute</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="s">&quot;position&quot;</span><span class="p">);</span>
</span><span class="lineno">25 </span>
<span class="lineno">26 </span>	<span class="c1">// Specify how the data for position can be accessed</span>
<span class="lineno">27 </span><span class="hll">	<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">position_attribute</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="lineno">28 </span>
<span class="lineno">29 </span>	<span class="c1">// Enable the attribute</span>
<span class="lineno">30 </span><span class="hll">	<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">position_attribute</span><span class="p">);</span>
</span><span class="lineno">31 </span><span class="p">}</span>
</pre></div> <p>We enable a <em>VAO</em> the same way as a <em>VBO</em>, except that in this case we are going to use <em>glGenVertexArrays</em> and <em>glBindVertexArray</em>, see lines 3 and 4 from the above code.</p> <p>The code from lines 5 to 19 was already discussed.</p> <p>With the helper functions we’ve discussed earlier, the process of creating a shader program was reduced to a single line of code, see line 21. Please note that I keep the shaders in separate files, in a folder named <em>shaders</em>.</p> <p>The following line gets the location of the attribute named <em>position</em> that enters in the vertex shader. Line 30 specifies how the data for the <em>position</em> attribute is sent to the shader. The last step that we need to do in order to have a working connection between the shaders and our C++ code is to enable the attribute.</p> <p>The <em>display</em> function contains two new instructions for actually drawing our four triangles:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">GLuint</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">2 </span>	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
<span class="lineno">3 </span>
<span class="lineno">4 </span><span class="hll">	<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
</span><span class="lineno">5 </span><span class="hll">	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</span><span class="lineno">6 </span>
<span class="lineno">7 </span>	<span class="c1">// Swap front and back buffers</span>
<span class="lineno">8 </span>	<span class="n">glfwSwapBuffers</span><span class="p">();</span>
<span class="lineno">9 </span><span class="p">}</span>
</pre></div> <p>The first highlighted line from the above code ensures that we are going to use the proper <em>VAO</em> and the next line actually draws the triangles specified in the <em>VBO</em> by 12 vertices:</p> <p><img src="/images/2013/05/13/four_triangles.png" alt="Four filled white triangles on a red background" width="500" class="center_image img-responsive"/></p> <p>If we want to draw points instead of triangles from the above vertices, we need to change line 5 from <em>display</em> to:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="hll">	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</span></pre></div> <p>We also need to enable <em>GL_PROGRAM_POINT_SIZE</em> in the <em>initialize</em> function:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="hll">	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_PROGRAM_POINT_SIZE</span><span class="p">);</span>
</span></pre></div> <p>With the above changes we can control the point size in pixels in the vertex shader with:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="hll">	<span class="n">gl_PointSize</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
</span></pre></div> <p>The default point size in OpenGL is 1.0. With a point size of 10px, this is what you should see (<em>ex_5.cpp</em> from the Github repository):</p> <p><img src="/images/2013/05/13/points.png" alt="OpenGL white points on a red background" width="500" class="center_image img-responsive"/></p> <p>What do you expect to see if you change <em>GL_POINTS</em> to <em>GL_LINES</em> ?</p> <p>By default, OpenGL fills a triangle with color, it is however possible to change this behavior if we use the function <em>glPolygonMode</em>. Copy <em>ex_4</em> to <em>ex_6</em> and add this line at the end of the <em>initialize</em> function:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="hll">	<span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">GL_LINE</span><span class="p">);</span>
</span></pre></div> <p>Now, OpenGL will draw for us a wireframe triangle:</p> <p><img src="/images/2013/05/13/wireframe_triangles.png" alt="OpenGL white lines on a red background" width="500" class="center_image img-responsive"/></p> <p>It’s time to add some color to our triangles. Suppose that we have a color associated with each vertex from our image and that we’ve generated somehow these colors; we are going to need 12 RGB colors. How can we send them to the fragment shader ? If we look again at our simplified scheme of the OpenGL pipeline, we see that the data goes first through the vertex shader. This means that we need to add our 12 colors to the <em>VBO</em> and include a new input variable, for colors, in the vertex shader. After the color data is in the vertex shader, we are going to need to pass it through for the next stages of the pipeline toward the fragment shader, we will use an <em>out</em> variable for this:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span><span class="cp">#version 150</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span><span class="n">in</span> <span class="n">vec4</span> <span class="n">position</span><span class="p">;</span>
<span class="lineno"> 4 </span><span class="hll"><span class="n">in</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span><span class="lineno"> 5 </span><span class="hll"><span class="n">out</span> <span class="n">vec4</span> <span class="n">color_from_vshader</span><span class="p">;</span>
</span><span class="lineno"> 6 </span>
<span class="lineno"> 7 </span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 8 </span>	<span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
<span class="lineno"> 9 </span><span class="hll">	<span class="n">color_from_vshader</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</span><span class="lineno">10 </span><span class="p">}</span>
</pre></div> <p>Similarly, the fragment shader needs to have an <em>in</em> variable (be sure to use the same name here as the name of the output from the vertex shader):</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span><span class="cp">#version 150</span>
<span class="lineno">2 </span>
<span class="lineno">3 </span><span class="n">in</span> <span class="n">vec4</span> <span class="n">color_from_vshader</span><span class="p">;</span>
<span class="lineno">4 </span><span class="hll"><span class="n">out</span> <span class="n">vec4</span> <span class="n">out_color</span><span class="p">;</span>
</span><span class="lineno">5 </span><span class="hll">
</span><span class="lineno">6 </span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">7 </span>	<span class="n">out_color</span> <span class="o">=</span> <span class="n">color_from_vshader</span><span class="p">;</span>
<span class="lineno">8 </span><span class="p">}</span>
</pre></div> <p>The <em>out_color</em> variable is implicitly bound to the output color from the fragment shader.</p> <p>Back to the C++ code now, we are going to need a new array for the color data, technically we could store the color data in the same array as the vertex positions. Using a different array, will let as try a new technique for transferring data to the <em>VBO</em>. Suppose the color data is stored in an array named <em>colors</em>.</p> <p>First, we need to allocate enough space for the <em>VBO</em> to store both the positions and the colors:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
<span class="lineno">2 </span><span class="hll">	<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">colors</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></pre></div> <p>We could use <em>glBufferSubData</em> to transfer <em>vertices_position</em> and <em>colors</em> to the <em>VBO</em>:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="c1">// Transfer the vertex positions:</span>
<span class="lineno">2 </span><span class="hll">	<span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">),</span> <span class="n">vertices_position</span><span class="p">);</span>
</span><span class="lineno">3 </span>
<span class="lineno">4 </span><span class="hll">	<span class="c1">// Transfer the vertex colors:</span>
</span><span class="lineno">5 </span>	<span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">colors</span><span class="p">),</span> <span class="n">colors</span><span class="p">);</span>
</pre></div> <p>The second argument of <em>glBufferSubData</em> is the offset at which the data is located, because we put the position data first in the <em>VBO</em>, the offset is 0. When we need to put the color data, the offset is equal to the size of the data that is already in the <em>VBO</em> <em>sizeof(vertices_positons)</em> in our case. The third parameter is the size of the data transferred and the fourth parameter a pointer to the data.</p> <p>Now, we need to add a new attribute, the color attribute, that enters the vertex shader:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="c1">// Color attribute</span>
<span class="lineno">2 </span>	<span class="n">GLint</span> <span class="n">color_attribute</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="s">&quot;color&quot;</span><span class="p">);</span>
<span class="lineno">3 </span><span class="hll">	<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">color_attribute</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">GLvoid</span> <span class="o">*</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vertices_position</span><span class="p">));</span>
</span><span class="lineno">4 </span>	<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">color_attribute</span><span class="p">);</span>
</pre></div> <p>The last argument from <em>glVertexAttribPointer</em> is a pointer to where the first element of the attribute is located.</p> <p>For a more interesting effect, we can fill <em>colors</em> with random numbers from 0 to 1:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span>	<span class="n">GLfloat</span> <span class="n">colors</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span>	<span class="c1">// Initialize the random seed from the system time</span>
<span class="lineno"> 4 </span>	<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="lineno"> 5 </span>
<span class="lineno"> 6 </span>	<span class="c1">// Fill colors with random numbers from 0 to 1, use continuous polynomials for r,g,b:</span>
<span class="lineno"> 7 </span>	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 8 </span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 9 </span>		<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">RAND_MAX</span><span class="p">;</span>
<span class="lineno">10 </span>		<span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="lineno">11 </span>		<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="lineno">12 </span>		<span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="lineno">13 </span>		<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="lineno">14 </span>		<span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">8.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="lineno">15 </span>		<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="lineno">16 </span>
<span class="lineno">17 </span>	<span class="p">}</span>
</pre></div> <p>The complete code for the last exercise can be found on the Github repository for this article as <em>ex_7</em>.</p> <p>If you run the code, you should see an image similar with this one:</p> <p><img src="/images/2013/05/13/random_colors.png" alt="Triangles filled with radom colours on a red background" width="500" class="center_image img-responsive"/></p> <p>Suppose now that we want to draw a square with the lower left corner at -0.5, -0.5 and the upper right corner at 0.5, 0.5. We can draw a square as a reunion of two triangular surfaces, basically we could use a strategy similar with the one we’ve used earlier, except that in this case we are going to have six vertices instead of twelve:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span>	<span class="c1">// 1 square (made by 2 triangles) to be rendered</span>
<span class="lineno"> 2 </span>	<span class="n">GLfloat</span> <span class="n">vertices_position</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno"> 3 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 4 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 5 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 6 </span>
<span class="lineno"> 7 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 8 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 9 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span>
<span class="lineno">10 </span>	<span class="p">};</span>
</pre></div> <p>In this case, the colors array will have 18 elements. Another change that should be made is in the <em>display</em> function, <em>glDrawArrays</em> should draw now 6 vertices. You can see the complete code as <em>ex_8.cpp</em> on Github.</p> <p>If you run the code, you will see an image similar with this one:</p> <p><img src="/images/2013/05/13/ineffective_square.png" alt="Square on a red background visible diagonal line" width="500" class="center_image img-responsive"/></p> <p>First thing that we should notice from the above image, is that the color is not smoothly distributed on the square surface, this is because the vertices -0.5, -0.5 and 0.5, 0.5 are repeated in our list of vertices and have different colors (see the way the color list is randomly generated).</p> <p>Please note that we use <em>sizeof(GLfloat)∗12</em> bytes for storing the vertices and <em>sizeof(GLfloat)∗18</em> to store the colors, this means that we need 120 bytes to store the data for drawing a square.</p> <p>A better way to represent our data will be to store the triangles as an array of indices pointing to an array of vertices, basically we will have one index per vertex:</p> <div class="highlight"><pre><span></span><span class="lineno"> 1 </span>	<span class="c1">// 1 square (made by 2 triangles) to be rendered</span>
<span class="lineno"> 2 </span>	<span class="n">GLfloat</span> <span class="n">vertices_position</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno"> 3 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 4 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 5 </span>		<span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 6 </span>		<span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="lineno"> 7 </span>	<span class="p">};</span>
<span class="lineno"> 8 </span>
<span class="lineno"> 9 </span>	<span class="n">GLuint</span> <span class="n">indices</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno">10 </span>		<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
<span class="lineno">11 </span>		<span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
<span class="lineno">12 </span>	<span class="p">};</span>
<span class="lineno">13 </span>
<span class="lineno">14 </span>	<span class="n">GLfloat</span> <span class="n">colors</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="lineno">15 </span>
<span class="lineno">16 </span>	<span class="p">...</span>
</pre></div> <p>In this case, the array of vertices will have unique entries, no vertices is repeated, this will also result in a reduction in the memory used to store the data for drawing a square. The memory consumption is now <em>sizeof(GLfloat)∗8</em> for the vertices, <em>sizeof(GLuint)∗6</em> for the indices and <em>sizeof(GLfloat)∗12</em> for the colors, on my machine this is 104 bytes. This may not sound like much for this particular case, but for a complex 3D scene the reduction in the memory consumption can be significative. Take as example a 3D cube, we have 6 faces and 8 vertices, using the first method our list of vertices will need to have 36 entries (in this case the memory consumption will be even larger because we’ll need to explicitly store 3 coordinates for each vertex), while with the second, more effective method, the list of vertices will have only 8 entries.</p> <p>The next figure exemplifies better how we can get the position for a square corner using the <em>indices</em> and the <em>vertices_position</em> arrays:</p> <p><img src="/images/2013/05/13/square_indices.jpg" alt="Unit rectangle with vertex coordinates and indices" width="521" class="center_image img-responsive"/></p> <p>How do we get the position for a particular triangle ? First we go in the indices array and we get the indices, for example the second triangle will have as indices 2, 3, 0. The second step is to go in the <em>vertices_position</em> array and get the actual position, for index = 3 we’ll have x = 0.5 and y = 0.5.</p> <p>Fortunately for us, OpenGL already has a special command for drawing data stored as arrays of indices and vertices, <em>glDrawElements</em>, and a special type of buffer data for storing the indices array, <em>GL_ELEMENT_ARRAY_BUFFER</em>.</p> <p>We’ll need to create an <em>Element Array Buffer</em>, bind it, allocate space and transfer the <em>indices</em> array to this buffer:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="c1">// Create an Element Array Buffer that will store the indices array:</span>
<span class="lineno">2 </span>	<span class="n">GLuint</span> <span class="n">eab</span><span class="p">;</span>
<span class="lineno">3 </span>	<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eab</span><span class="p">);</span>
<span class="lineno">4 </span>
<span class="lineno">5 </span>	<span class="c1">// Transfer the data from indices to eab</span>
<span class="lineno">6 </span>	<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">eab</span><span class="p">);</span>
<span class="lineno">7 </span>	<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></div> <p>And the draw command is now:</p> <div class="highlight"><pre><span></span><span class="lineno">1 </span>	<span class="n">glDrawElements</span><span class="p">(</span> <span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div> <p>The complete code for this example is on the Github repository for this article as <em>ex_9.cpp</em>.</p> <p>If you run the code, you should see an image similar with this one:</p> <p><img src="/images/2013/05/13/effective_square.png" alt="Square filled with color" width="500" class="center_image img-responsive"/></p> <p>In the <a href="/2013/05/17/opengl-101-textures/">next tutorial</a>, we are going to learn how to work with textures in OpenGL and how to load an image from the disk, with <em>FreeImage</em>.</p> <p>All posts from this series:</p> <ul> <li><a href="/2013/05/10/opengl-101-windows-osx-linux-getting-started/">OpenGL 101: Windows, OS X and Linux - Getting Started</a></li> <li><a href="/2013/05/13/opengl-101-drawing-primitives/">OpenGL 101: Drawing primitives - points, lines and triangles</a></li> <li><a href="/2013/05/17/opengl-101-textures/">OpenGL 101: Textures</a></li> <li><a href="/2013/05/22/opengl-101-matrices-projection-view-model/">OpenGL 101: Matrices - projection, view, model</a></li> </ul> <p><a id="book">If</a> you are interested to learn more about OpenGL, I would recommend reading <a href="https://www.amazon.com/exec/obidos/ASIN/0321902947/solarianprogr-20/" rel="nofollow" class="amzn">OpenGL SuperBible</a> 6th edition by G. Sellers, S Wright and N. Haemel:</p> <p><a href="https://www.amazon.com/exec/obidos/ASIN/0321902947/solarianprogr-20/" rel="nofollow" class="amzn"><img src="/images/amzn/0321902947.jpg" alt=""/></a></p> <p>or</p> <p><a href="https://www.amazon.com/exec/obidos/ASIN/0321773039/solarianprogr-20/" rel="nofollow" class="amzn">OpenGL Programming Guide</a> by D. Shreiner, G. Sellers, J. M. Kessenich, B. M. Licea-Kane:</p> <p><a href="https://www.amazon.com/exec/obidos/ASIN/0321773039/solarianprogr-20/" rel="nofollow" class="amzn"><img src="/images/amzn/0321773039.jpg" alt=""/></a></p> <br> <div id="disqus_thread"></div> <div class="row" id="show-comments" onclick="show_comments(this)"> Show Comments </div> <script type="text/javascript">
                        var disqus_shortname = 'solarianprogrammer';

                        function show_comments(div) {
                            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                            div.parentNode.removeChild(div);
                        }
                    </script> <hr/> </article> <section id="sidebar" class="col-md-4"> <section id="advert2" class="col-md-3"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-5384871893435364" data-ad-slot="8286352329"></ins> <script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script> </section> <nav id="categories" class="row"> <p>Categories</p> <a class="categories_links" href="/categories/x86-64" rel="bookmark" title="Permanent link to ">x86-64</a> <a class="categories_links" href="/categories/WSL" rel="bookmark" title="Permanent link to ">WSL</a> <a class="categories_links" href="/categories/Scheme" rel="bookmark" title="Permanent link to ">Scheme</a> <a class="categories_links" href="/categories/Posix" rel="bookmark" title="Permanent link to ">Posix</a> <a class="categories_links" href="/categories/C++" rel="bookmark" title="Permanent link to ">C++</a> <a class="categories_links" href="/categories/Clang" rel="bookmark" title="Permanent link to ">Clang</a> <a class="categories_links" href="/categories/C99" rel="bookmark" title="Permanent link to ">C99</a> <a class="categories_links" href="/categories/macOS" rel="bookmark" title="Permanent link to ">macOS</a> <a class="categories_links" href="/categories/OSX" rel="bookmark" title="Permanent link to ">OSX</a> <a class="categories_links" href="/categories/Python" rel="bookmark" title="Permanent link to ">Python</a> <a class="categories_links" href="/categories/Roguelike" rel="bookmark" title="Permanent link to ">Roguelike</a> <a class="categories_links" href="/categories/C++17" rel="bookmark" title="Permanent link to ">C++17</a> <a class="categories_links" href="/categories/Multithreading" rel="bookmark" title="Permanent link to ">Multithreading</a> <a class="categories_links" href="/categories/CUDA" rel="bookmark" title="Permanent link to ">CUDA</a> <a class="categories_links" href="/categories/C++11" rel="bookmark" title="Permanent link to ">C++11</a> <a class="categories_links" href="/categories/ChromeOS" rel="bookmark" title="Permanent link to ">ChromeOS</a> <a class="categories_links" href="/categories/Raspberry Pi" rel="bookmark" title="Permanent link to ">Raspberry Pi</a> <a class="categories_links" href="/categories/Fractals" rel="bookmark" title="Permanent link to ">Fractals</a> <a class="categories_links" href="/categories/Fsharp" rel="bookmark" title="Permanent link to ">F#</a> <a class="categories_links" href="/categories/Charts" rel="bookmark" title="Permanent link to ">Charts</a> <a class="categories_links" href="/categories/Chromebook" rel="bookmark" title="Permanent link to ">Chromebook</a> <a class="categories_links" href="/categories/GCC" rel="bookmark" title="Permanent link to ">GCC</a> <a class="categories_links" href="/categories/Books" rel="bookmark" title="Permanent link to ">Books</a> <a class="categories_links" href="/categories/Regex" rel="bookmark" title="Permanent link to ">Regex</a> <a class="categories_links" href="/categories/NumPy" rel="bookmark" title="Permanent link to ">NumPy</a> <a class="categories_links" href="/categories/iOS" rel="bookmark" title="Permanent link to ">iOS</a> <a class="categories_links" href="/categories/dotnet" rel="bookmark" title="Permanent link to ">.NET</a> <a class="categories_links" href="/categories/Arduino" rel="bookmark" title="Permanent link to ">Arduino</a> <a class="categories_links" href="/categories/Videos" rel="bookmark" title="Permanent link to ">Videos</a> <a class="categories_links" href="/categories/Node.js" rel="bookmark" title="Permanent link to ">Node.js</a> <a class="categories_links" href="/categories/Cling" rel="bookmark" title="Permanent link to ">Cling</a> <a class="categories_links" href="/categories/OpenCV" rel="bookmark" title="Permanent link to ">OpenCV</a> <a class="categories_links" href="/categories/Swift" rel="bookmark" title="Permanent link to ">Swift</a> <a class="categories_links" href="/categories/Linux" rel="bookmark" title="Permanent link to ">Linux</a> <a class="categories_links" href="/categories/Perlin" rel="bookmark" title="Permanent link to ">Perlin</a> <a class="categories_links" href="/categories/Matplotlib" rel="bookmark" title="Permanent link to ">Matplotlib</a> <a class="categories_links" href="/categories/Fortran" rel="bookmark" title="Permanent link to ">Fortran</a> <a class="categories_links" href="/categories/Csharp" rel="bookmark" title="Permanent link to ">C#</a> <a class="categories_links" href="/categories/C++14" rel="bookmark" title="Permanent link to ">C++14</a> <a class="categories_links" href="/categories/JavaScript" rel="bookmark" title="Permanent link to ">JavaScript</a> <a class="categories_links" href="/categories/Windows" rel="bookmark" title="Permanent link to ">Windows</a> <a class="categories_links" href="/categories/C11" rel="bookmark" title="Permanent link to ">C11</a> <a class="categories_links" href="/categories/C" rel="bookmark" title="Permanent link to ">C</a> <a class="categories_links" href="/categories/SciPy" rel="bookmark" title="Permanent link to ">SciPy</a> <a class="categories_links" href="/categories/Objective-C" rel="bookmark" title="Permanent link to ">Objective-C</a> <a class="categories_links" href="/categories/Armadillo" rel="bookmark" title="Permanent link to ">Armadillo</a> <a class="categories_links" href="/categories/OpenMP" rel="bookmark" title="Permanent link to ">OpenMP</a> <a class="categories_links" href="/categories/Productivity" rel="bookmark" title="Permanent link to ">Productivity</a> <a class="categories_links" href="/categories/OpenGL" rel="bookmark" title="Permanent link to ">OpenGL</a> </nav> <form action="https://www.paypal.me/solarianprogrammer/5usd" target="_blank"> <input class="row" id="show-support" type="submit" value="Support my blog with a PayPal donation"/> </form> <nav id="last_articles" class="row"> <p>Recent posts</p> <ul> <li> <a href="/2018/09/28/installing-openjdk-macos/" rel="bookmark" title="Permanent link to ">Installing OpenJDK 11 on macOS Mojave</a> </li> <li> <a href="/2018/09/23/cpp-17-constexpr-generation-fizzbuzz-solution/" rel="bookmark" title="Permanent link to ">C++17 constexpr generation of a FizzBuzz solution</a> </li> <li> <a href="/2018/09/22/install-ruby-macos-windows-ubuntu/" rel="bookmark" title="Permanent link to ">Install Ruby 2.5 on macOS, Windows 10 and Ubuntu 18.04</a> </li> <li> <a href="/2018/08/13/create-net-core-fsharp-app-generate-executables-multiple-operating-systems/" rel="bookmark" title="Permanent link to ">How to create a .NET Core F# application and generate executables for multiple operating systems</a> </li> <li> <a href="/2018/08/07/compiling-boost-gcc-clang-macos/" rel="bookmark" title="Permanent link to ">Compiling Boost with GCC or Clang on macOS</a> </li> <li> <a href="/2018/05/06/building-gcc-cross-compiler-raspberry-pi/" rel="bookmark" title="Permanent link to ">Building GCC as a cross compiler for Raspberry Pi</a> </li> <li> <a href="/2018/04/25/install-numpy-scipy-matplotlib-opencv-python-ubuntu/" rel="bookmark" title="Permanent link to ">Install NumPy, SciPy, Matplotlib and OpenCV for Python 3 on Ubuntu 18.04</a> </li> <li> <a href="/2018/04/22/raspberry-pi-raspbian-install-clang-compile-cpp-17-programs/" rel="bookmark" title="Permanent link to ">Raspberry Pi - Install Clang 6 and compile C++17 programs</a> </li> <li> <a href="/2018/04/21/python-opencv-show-video-tkinter-window/" rel="bookmark" title="Permanent link to ">Python OpenCV - show a video in a Tkinter window</a> </li> <li> <a href="/2018/04/20/python-opencv-show-image-tkinter-window/" rel="bookmark" title="Permanent link to ">Python OpenCV - show an image in a Tkinter window</a> </li> </ul> </nav> <nav id="social_links" class="row"> <div id="RSS" class="col-md-3 col-xs-2"> <a href="https://feeds.feedburner.com/SolarianProgrammer" target="_blank"> <img src="/images/common/rss.png" alt="My RSS" style="border: 0;" height="50" width="50"> </a> </div> <div id="RSS_twitter" class="col-md-3 col-xs-2"> <a href="https://twitter.com/sol_prog" target="_blank"> <img src="/images/common/twitter.png" alt="My Twitter" style="border: 0;" height="50" width="50"> </a> </div> </nav> </section> </section> <footer class="row"> <div class="col-md-12"> <p id="blog_disclaimer"><strong>Disclaimer:</strong><br> <em>All data and information provided on this site is for informational purposes only. solarianprogrammer.com makes no representations as to accuracy, completeness, currentness, suitability, or validity of any information on this site and will not be liable for any errors, omissions, or delays in this information or any losses, injuries, or damages arising from its display or use. All information is provided on an as-is basis. solarianprogrammer.com does not collect any personal information about its visitors except that which they provide voluntarily when leaving comments. This information will never be disclosed to any third party for any purpose. Some of the links contained within this site have my referral id, which provides me with a small commission for each sale. Thank you for understanding.</em></p> <p id="blog_copyright">Copyright &copy; 2018 - solarianprogrammer.com</p> </div> </footer> <div id="amzn-assoc-ad-3eeac002-2edb-4e13-889a-ed8b02689e30"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=3eeac002-2edb-4e13-889a-ed8b02689e30"></script> <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      },
      "HTML-CSS": {  linebreaks: { automatic: true }, matchFontHeight: false },
      "SVG": {  linebreaks: { automatic: true }, matchFontHeight: false }
    });

    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

  </script> <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script> </div> </body> </html>